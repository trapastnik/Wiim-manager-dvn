#!/usr/bin/env node

/**
 * WiiM Mini Web Control - Standalone Version
 * –û–¥–∏–Ω —Ñ–∞–π–ª —Å–æ –≤—Å–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–º —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–æ–º
 * –ó–∞–ø—É—Å–∫: node standalone.js
 */

import https from 'https';
import http from 'http';
import { readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// ========================================
// –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø
// ========================================

let WIIM_IP = '192.168.0.19';
let PORT = 3000;
let USE_HTTPS = true;

// –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å .env –µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
try {
  const envPath = join(__dirname, '.env');
  const envFile = readFileSync(envPath, 'utf-8');
  envFile.split('\n').forEach(line => {
    line = line.trim();
    if (line && !line.startsWith('#')) {
      const [key, ...valueParts] = line.split('=');
      const value = valueParts.join('=').trim();
      if (key.trim() === 'WIIM_IP') WIIM_IP = value;
      if (key.trim() === 'PORT') PORT = parseInt(value);
      if (key.trim() === 'WIIM_USE_HTTPS') USE_HTTPS = value !== 'false';
    }
  });
} catch (e) {
  console.log('–ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é');
}

// ========================================
// WiiM CLIENT
// ========================================

class WiiMClient {
  constructor(ipAddress, useHttps = true) {
    this.baseUrl = (useHttps ? 'https://' : 'http://') + ipAddress;
    this.useHttps = useHttps;
    this.agent = useHttps ? new https.Agent({ rejectUnauthorized: false }) : null;
  }

  decodeHex(hexString) {
    if (!hexString || hexString === 'Unknown') return 'Unknown';

    try {
      let str = '';
      for (let i = 0; i < hexString.length; i += 2) {
        const charCode = parseInt(hexString.substr(i, 2), 16);
        if (charCode > 0) str += String.fromCharCode(charCode);
      }
      return str || hexString;
    } catch (e) {
      return hexString;
    }
  }

  decodeTURI(str){
    return decodeURI(str.split('').reduce((str, char) => (!str || str[str.length-3] == '%') ? str + '%' + char : str + char, ''))
  }

  processPlayerData(data) {
    if (!data) return data;
    const processed = Object.assign({}, data);
    if (processed.Title) processed.Title = this.decodeTURI(processed.Title);
    if (processed.Artist) processed.Artist = this.decodeTURI(processed.Artist);
    if (processed.Album) processed.Album = this.decodeTURI(processed.Album);
    return processed;
  }

  async request(endpoint) {
    const url = this.baseUrl + endpoint;
    const client = this.useHttps ? https : http;

    return new Promise((resolve, reject) => {
      const req = client.get(url, { agent: this.agent, timeout: 5000 }, (res) => {
        let data = '';
        res.on('data', (chunk) => { data += chunk; });
        res.on('end', () => {
          try {
            const result = data ? JSON.parse(data) : {};
            const processed = this.processPlayerData(result);
            resolve({ status: res.statusCode, data: processed });
          } catch (e) {
            resolve({ status: res.statusCode, data: data });
          }
        });
      });
      req.on('error', (error) => { reject(error); });
      req.on('timeout', () => { req.destroy(); reject(new Error('Request timeout')); });
      req.end();
    });
  }

  async getPlayerStatus() {
    return await this.request('/httpapi.asp?command=getPlayerStatus');
  }

  async play() { return await this.request('/httpapi.asp?command=setPlayerCmd:play'); }
  async pause() { return await this.request('/httpapi.asp?command=setPlayerCmd:pause'); }
  async stop() { return await this.request('/httpapi.asp?command=setPlayerCmd:stop'); }
  async next() { return await this.request('/httpapi.asp?command=setPlayerCmd:next'); }
  async prev() { return await this.request('/httpapi.asp?command=setPlayerCmd:prev'); }

  async setVolume(volume) {
    const vol = Math.max(0, Math.min(100, parseInt(volume)));
    return await this.request('/httpapi.asp?command=setPlayerCmd:vol:' + vol);
  }

  async volumeUp() { return await this.request('/httpapi.asp?command=setPlayerCmd:vol+'); }
  async volumeDown() { return await this.request('/httpapi.asp?command=setPlayerCmd:vol-'); }
  async mute() { return await this.request('/httpapi.asp?command=setPlayerCmd:mute:1'); }
  async unmute() { return await this.request('/httpapi.asp?command=setPlayerCmd:mute:0'); }
}

const wiimClient = new WiiMClient(WIIM_IP, USE_HTTPS);

// ========================================
// HTML TEMPLATE
// ========================================

const HTML_TEMPLATE = `<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WiiM Mini Control</title>
    <style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
}

.container {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 20px;
    padding: 30px;
    max-width: 500px;
    width: 100%;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
    padding-bottom: 20px;
    border-bottom: 2px solid #eee;
}

h1 {
    font-size: 28px;
    color: #333;
    font-weight: 600;
}

.status {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    font-size: 16px;
    line-height: 1;
}

.status.online { color: #10b981; }
.status.offline { color: #ef4444; }

.system-messages {
    background: #1f2937;
    border-radius: 8px;
    padding: 12px 16px;
    margin-bottom: 20px;
    max-height: 200px;
    overflow-y: auto;
    font-family: 'Courier New', monospace;
    font-size: 12px;
}

.message-item {
    color: #9ca3af;
    padding: 4px 0;
    border-bottom: 1px solid #374151;
}

.message-item:last-child { border-bottom: none; }
.message-item.error { color: #ef4444; }
.message-item.success { color: #10b981; }
.message-item.info { color: #3b82f6; }
.message-item.warning { color: #f59e0b; }

.player-info {
    background: #f8fafc;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 30px;
}

.track-info { margin-bottom: 10px; }

.track-title {
    font-size: 18px;
    font-weight: 600;
    color: #1f2937;
    margin-bottom: 5px;
}

.track-artist {
    font-size: 14px;
    color: #6b7280;
}

.player-state {
    font-size: 12px;
    color: #9ca3af;
    text-transform: uppercase;
    font-weight: 500;
}

.controls { margin-bottom: 20px; }

.playback-controls {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-bottom: 25px;
}

.volume-controls {
    display: flex;
    align-items: center;
    gap: 12px;
}

.btn {
    background: #667eea;
    color: white;
    border: none;
    border-radius: 10px;
    padding: 12px 20px;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.2s;
    font-weight: 500;
}

.btn:hover {
    background: #5568d3;
    transform: translateY(-2px);
}

.btn:active { transform: translateY(0); }

.btn-play {
    background: #10b981;
    padding: 15px 25px;
    font-size: 24px;
}

.btn-play:hover { background: #059669; }

.btn-small {
    padding: 8px 12px;
    font-size: 16px;
    min-width: 40px;
}

.btn-secondary { background: #6b7280; }
.btn-secondary:hover { background: #4b5563; }

#volume-slider {
    flex: 1;
    height: 6px;
    border-radius: 3px;
    outline: none;
    -webkit-appearance: none;
    background: #e5e7eb;
}

#volume-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #667eea;
    cursor: pointer;
}

#volume-slider::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #667eea;
    cursor: pointer;
    border: none;
}

#volume-value {
    min-width: 35px;
    text-align: center;
    font-weight: 600;
    color: #4b5563;
}

.actions {
    display: flex;
    gap: 10px;
    justify-content: space-between;
}

.actions .btn {
    flex: 1;
    font-size: 14px;
    padding: 10px;
}

@media (max-width: 480px) {
    .container { padding: 20px; }
    h1 { font-size: 24px; }
    .btn { padding: 10px 15px; font-size: 18px; }
    .btn-play { padding: 12px 20px; font-size: 22px; }
}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>WiiM Mini</h1>
            <div id="connection-status" class="status offline">‚óè</div>
        </header>

        <div class="system-messages" id="system-messages">
            <div class="message-item">–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è...</div>
        </div>

        <div class="player-info">
            <div class="track-info">
                <div id="track-title" class="track-title">‚Äî</div>
                <div id="track-artist" class="track-artist">‚Äî</div>
            </div>
            <div id="player-state" class="player-state">‚Äî</div>
        </div>

        <div class="controls">
            <div class="playback-controls">
                <button class="btn" onclick="control('prev')">‚èÆ</button>
                <button class="btn btn-play" id="play-pause" onclick="togglePlayPause()">‚ñ∂</button>
                <button class="btn" onclick="control('next')">‚è≠</button>
            </div>

            <div class="volume-controls">
                <button class="btn btn-small" onclick="volumeControl('down')">‚àí</button>
                <input type="range" id="volume-slider" min="0" max="100" value="50"
                       oninput="setVolume(this.value)" onchange="setVolume(this.value)">
                <span id="volume-value">50</span>
                <button class="btn btn-small" onclick="volumeControl('up')">+</button>
                <button class="btn btn-small" id="mute-btn" onclick="toggleMute()">üîä</button>
            </div>
        </div>

        <div class="actions">
            <button class="btn btn-secondary" onclick="refreshStatus()">–û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å</button>
            <button class="btn btn-secondary" onclick="control('stop')">Stop</button>
        </div>
    </div>

    <script>
let currentVolume = 50;
let isMuted = false;
let isPlaying = false;
let messageCounter = 0;
const MAX_MESSAGES = 50;

document.addEventListener('DOMContentLoaded', () => {
    addMessage('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...', 'info');
    refreshStatus();
    setInterval(refreshStatus, 3000);
});

function addMessage(text, type = 'info') {
    const container = document.getElementById('system-messages');
    const timestamp = new Date().toLocaleTimeString('ru-RU');
    const messageDiv = document.createElement('div');
    messageDiv.className = \`message-item \${type}\`;
    messageDiv.textContent = \`[\${timestamp}] \${text}\`;
    container.appendChild(messageDiv);
    messageCounter++;
    if (messageCounter > MAX_MESSAGES) {
        container.removeChild(container.firstChild);
        messageCounter--;
    }
    container.scrollTop = container.scrollHeight;
}

async function refreshStatus() {
    try {
        addMessage('–ó–∞–ø—Ä–æ—Å —Å—Ç–∞—Ç—É—Å–∞ –ø–ª–µ–µ—Ä–∞...', 'info');
        const response = await fetch('/api/info');
        const data = await response.json();

        if (data.error) {
            addMessage(\`–û—à–∏–±–∫–∞ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞: \${data.error}\`, 'error');
            updateConnectionStatus(false);
            return;
        }

        if (data.status === 200 && data.data) {
            addMessage(\`–°—Ç–∞—Ç—É—Å –ø–æ–ª—É—á–µ–Ω: \${data.data.status || 'unknown'}\`, 'success');
            addMessage(\`–¢—Ä–µ–∫: \${data.data.Title || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'} - \${data.data.Artist || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}\`, 'info');
            updateUI(data.data);
            updateConnectionStatus(true);
        } else if (response.ok) {
            addMessage(\`–ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞: \${JSON.stringify(data).substring(0, 100)}\`, 'warning');
            updateConnectionStatus(false);
        } else {
            addMessage(\`HTTP –æ—à–∏–±–∫–∞: \${response.status}\`, 'error');
            updateConnectionStatus(false);
        }
    } catch (error) {
        addMessage(\`–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: \${error.message}\`, 'error');
        updateConnectionStatus(false);
    }
}

function updateUI(data) {
    document.getElementById('track-title').textContent = data.Title || '‚Äî';
    document.getElementById('track-artist').textContent = data.Artist || '‚Äî';
    const status = data.status || 'stop';
    document.getElementById('player-state').textContent = status;
    isPlaying = status === 'play';
    document.getElementById('play-pause').textContent = isPlaying ? '‚è∏' : '‚ñ∂';
    if (data.vol !== undefined) {
        currentVolume = parseInt(data.vol);
        document.getElementById('volume-slider').value = currentVolume;
        document.getElementById('volume-value').textContent = currentVolume;
    }
    if (data.mute !== undefined) {
        isMuted = data.mute === '1';
        updateMuteButton();
    }
}

function updateConnectionStatus(online) {
    const status = document.getElementById('connection-status');
    status.className = online ? 'status online' : 'status offline';
}

async function control(action) {
    try {
        addMessage(\`–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã: \${action}\`, 'info');
        const response = await fetch(\`/api/control/\${action}\`, { method: 'POST' });
        if (response.ok) {
            addMessage(\`–ö–æ–º–∞–Ω–¥–∞ \${action} –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ\`, 'success');
            setTimeout(refreshStatus, 500);
        } else {
            addMessage(\`–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è \${action}: HTTP \${response.status}\`, 'error');
        }
    } catch (error) {
        addMessage(\`–û—à–∏–±–∫–∞ –∫–æ–º–∞–Ω–¥—ã \${action}: \${error.message}\`, 'error');
    }
}

async function togglePlayPause() {
    const action = isPlaying ? 'pause' : 'play';
    await control(action);
}

async function volumeControl(action) {
    try {
        addMessage(\`–†–µ–≥—É–ª–∏—Ä–æ–≤–∫–∞ –≥—Ä–æ–º–∫–æ—Å—Ç–∏: \${action}\`, 'info');
        const response = await fetch(\`/api/volume/\${action}\`, { method: 'POST' });
        if (response.ok) {
            addMessage(\`–ì—Ä–æ–º–∫–æ—Å—Ç—å \${action === 'up' ? '—É–≤–µ–ª–∏—á–µ–Ω–∞' : '—É–º–µ–Ω—å—à–µ–Ω–∞'}\`, 'success');
        }
        setTimeout(refreshStatus, 300);
    } catch (error) {
        addMessage(\`–û—à–∏–±–∫–∞ —Ä–µ–≥—É–ª–∏—Ä–æ–≤–∫–∏ –≥—Ä–æ–º–∫–æ—Å—Ç–∏: \${error.message}\`, 'error');
    }
}

async function setVolume(value) {
    try {
        document.getElementById('volume-value').textContent = value;
        const response = await fetch('/api/volume/set', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ volume: parseInt(value) })
        });
        if (response.ok) {
            addMessage(\`–ì—Ä–æ–º–∫–æ—Å—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: \${value}\`, 'success');
        }
    } catch (error) {
        addMessage(\`–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≥—Ä–æ–º–∫–æ—Å—Ç–∏: \${error.message}\`, 'error');
    }
}

async function toggleMute() {
    try {
        const action = isMuted ? 'unmute' : 'mute';
        addMessage(\`\${action === 'mute' ? '–û—Ç–∫–ª—é—á–µ–Ω–∏–µ' : '–í–∫–ª—é—á–µ–Ω–∏–µ'} –∑–≤—É–∫–∞\`, 'info');
        const response = await fetch(\`/api/volume/\${action}\`, { method: 'POST' });
        if (response.ok) {
            addMessage(\`–ó–≤—É–∫ \${action === 'mute' ? '–æ—Ç–∫–ª—é—á–µ–Ω' : '–≤–∫–ª—é—á–µ–Ω'}\`, 'success');
        }
        isMuted = !isMuted;
        updateMuteButton();
        setTimeout(refreshStatus, 300);
    } catch (error) {
        addMessage(\`–û—à–∏–±–∫–∞ mute: \${error.message}\`, 'error');
    }
}

function updateMuteButton() {
    document.getElementById('mute-btn').textContent = isMuted ? 'üîá' : 'üîä';
}
    </script>
</body>
</html>`;

// ========================================
// HTTP SERVER
// ========================================

const server = http.createServer(async (req, res) => {
  const url = req.url;

  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }

  // Main page
  if (url === '/' || url === '/index.html') {
    res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
    res.end(HTML_TEMPLATE);
    return;
  }

  // API endpoints
  if (url === '/api/status' || url === '/api/info') {
    try {
      const result = await wiimClient.getPlayerStatus();
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify(result));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // Control endpoints
  const controlMatch = url.match(/^\/api\/control\/(play|pause|stop|next|prev)$/);
  if (controlMatch && req.method === 'POST') {
    try {
      const action = controlMatch[1];
      const result = await wiimClient[action]();
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify(result));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // Volume endpoints
  if (url === '/api/volume/set' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => { body += chunk; });
    req.on('end', async () => {
      try {
        const { volume } = JSON.parse(body);
        const result = await wiimClient.setVolume(volume);
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(result));
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
    return;
  }

  const volumeMatch = url.match(/^\/api\/volume\/(up|down|mute|unmute)$/);
  if (volumeMatch && req.method === 'POST') {
    try {
      const action = volumeMatch[1];
      let result;
      if (action === 'up') result = await wiimClient.volumeUp();
      else if (action === 'down') result = await wiimClient.volumeDown();
      else if (action === 'mute') result = await wiimClient.mute();
      else if (action === 'unmute') result = await wiimClient.unmute();

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify(result));
    } catch (error) {
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message }));
    }
    return;
  }

  // 404
  res.writeHead(404, { 'Content-Type': 'text/plain' });
  res.end('Not Found');
});

// ========================================
// START SERVER
// ========================================

server.listen(PORT, '0.0.0.0', () => {
  console.log('');
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë   WiiM Mini Web Control - Standalone  ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  console.log('');
  console.log(`‚úì –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);
  console.log(`‚úì WiiM –ø–ª–µ–µ—Ä: ${USE_HTTPS ? 'https' : 'http'}://${WIIM_IP}`);
  console.log('');
  console.log('–î–æ—Å—Ç—É–ø:');
  console.log(`  ‚Üí –õ–æ–∫–∞–ª—å–Ω–æ:      http://localhost:${PORT}`);
  console.log(`  ‚Üí –í —Å–µ—Ç–∏:        http://<your-ip>:${PORT}`);
  console.log('');
  console.log('–î–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞–∂–º–∏—Ç–µ Ctrl+C');
  console.log('');
});
